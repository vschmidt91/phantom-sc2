- Macro structure placement search lives in `phantom/macro/builder.py` (`_get_structure_target`).
- `python-sc2` `find_placement` is async, so placement changes require async propagation through `Builder.get_actions` -> `Agent.on_step` -> `PhantomBot.on_step`.
- For minimal impact, structure placement can keep random sampling and use async `can_place_single` for validity checks.
- `ScoutProxy._pick_target_for` now prioritizes youngest unscouted candidate tiles (lowest age), with distance to own natural only as tie-breaker.
- `ScoutProxy._pick_target_for` now samples exactly one random `circle_perimeter` tile per radius step (up to `_samples_max` radii).
- `Makefile` uses `poetry run`; `check` now covers `ruff check` + `ruff format --check` + `mypy` + `compileall`, while unit tests run via `make test`/`make ci`.
- Runtime imports in bundled `ares` (`ares-sc2/src`) require `map_analyzer`; root `pyproject.toml` currently places `map-analyzer` only in optional `build` extras, so default installs can fail with `ModuleNotFoundError`.
- ZvZ creep spread can be limited by a convex-hull target filter built from `mediator.get_creep_edges`.
- `mediator.get_creep_edges` returns `(x_coords, y_coords)` numpy arrays, not an iterable of point tuples.
- ZvZ creep hull is now incremental: seeded from start/nat/defensive-third rings (10 points each), then extended by 10 new ring points on each completed hatchery via `Agent.on_structure_completed`.
- Queen frontline overcommit stems from control layering: `Queens._get_action` calls `situation.fight_with` when unsafe, but queens are excluded from combatant target assignment (`Observation.combatants`), `fight_with` auto-shoots in-range for ranged units, transfuse runs later and can overwrite retreat with forward `Move`.
- Fix applied: unsafe queens now use retreat primitives (`retreat_to_creep`/`retreat_with`/`move_to_safe_spot`) instead of `fight_with`; transfuse no longer issues out-of-range chase `Move`, so it won't overwrite retreat with forward motion.
- `phantom/counters` now contains standalone prep scaffolding for the `mlp_composition` idea (feature-space + table extraction + tiny MLP + decoder + serialization) plus `notebooks/mlp_composition_visualization.ipynb`; it is intentionally not integrated into runtime strategy yet.
- Assignment solving is now split into `phantom/common/distribute/{cpg,hs}` behind `phantom.common.distribute`; CVXPYGEN uses a single precompiled `harvestN` module (loaded from `bin/cpg` or legacy `bin/harvest*`) with HiGHS fallback for unsupported sizes or missing binaries.
- CVXPYGEN `cpg_prim.x` is column-major (`order="F"` reshape) and must be interpreted that way; using row-major reshape silently breaks row-equality constraints.
- `scripts/compile_cvxpy.py` emits every `harvestN` module into `bin/cpg` (renamed to `harvestN*`) and builds cumulatively for each `1..log2-size`. The final artifact bundle is `bin/cpg.tar.xz`, and temporary workdirs live under `{output_dir}/tmp` and `tempfile`.
- On Windows, `scripts/compile_cvxpy.py` needs robust CMake discovery (`--cmake` / `PHANTOM_CMAKE` / Python `cmake` wheel), temporary `sys.path` injection for `build_root` during `cpg.generate_code`, and subprocess-based `cpg_module` import verification to avoid pybind11 re-registration errors.
- `scripts/compile_cvxpy.py`: keep both path mutations: prepend CMake dir to `PATH` (generated builds call `cmake` by name) and temporarily prepend `build_root` to `sys.path` (so `cpg.generate_code` can import generated `harvestN.cpg_solver`); these can be implemented as `insert`/`pop` instead of full `sys.path` copies.
- `scripts/compile_cvxpy.py` import verification must use `importlib.machinery.EXTENSION_SUFFIXES` (not only `.pyd`) so CI on Debian can validate generated extension modules (`.so`).
- In rounded assignment LPs (`phantom/common/distribute.py`), avoid `np.inf` objective padding; keep costs finite and disable invalid padded arcs via variable bounds (`ub=0`), with padded target capacities based on compiled `self.n` to preserve feasibility.
