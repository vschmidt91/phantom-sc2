- Macro structure placement search lives in `phantom/macro/builder.py` (`_get_structure_target`).
- `python-sc2` `find_placement` is async, so placement changes require async propagation through `Builder.get_actions` -> `Agent.on_step` -> `PhantomBot.on_step`.
- For minimal impact, structure placement can keep random sampling and use async `can_place_single` for validity checks.
- `ScoutProxy._pick_target_for` now prioritizes youngest unscouted candidate tiles (lowest age), with distance to own natural only as tie-breaker.
- `ScoutProxy._pick_target_for` now samples exactly one random `circle_perimeter` tile per radius step (up to `_samples_max` radii).
- `Makefile` uses `poetry run`; `check` now covers `ruff check` + `ruff format --check` + `mypy` + `compileall`, while unit tests run via `make test`/`make ci`.
- Runtime imports in bundled `ares` (`ares-sc2/src`) require `map_analyzer`; root `pyproject.toml` currently places `map-analyzer` only in optional `build` extras, so default installs can fail with `ModuleNotFoundError`.
- ZvZ creep spread can be limited by a convex-hull target filter built from `mediator.get_creep_edges`.
- `mediator.get_creep_edges` returns `(x_coords, y_coords)` numpy arrays, not an iterable of point tuples.
- ZvZ creep hull is now incremental: seeded from start/nat/defensive-third rings (10 points each), then extended by 10 new ring points on each completed hatchery via `Agent.on_structure_completed`.
- Queen frontline overcommit stems from control layering: `Queens._get_action` calls `situation.fight_with` when unsafe, but queens are excluded from combatant target assignment (`Observation.combatants`), `fight_with` auto-shoots in-range for ranged units, transfuse runs later and can overwrite retreat with forward `Move`.
- Fix applied: unsafe queens now use retreat primitives (`retreat_to_creep`/`retreat_with`/`move_to_safe_spot`) instead of `fight_with`; transfuse no longer issues out-of-range chase `Move`, so it won't overwrite retreat with forward motion.
- `phantom/counters` now contains standalone prep scaffolding for the `mlp_composition` idea (feature-space + table extraction + tiny MLP + decoder + serialization) plus `notebooks/mlp_composition_visualization.ipynb`; it is intentionally not integrated into runtime strategy yet.
- Assignment solving is now split into `phantom/common/distribute/{cpg,hs}` behind `phantom.common.distribute`; CVXPYGEN uses a single precompiled `harvestN` module (loaded from `bin/cpg` or legacy `bin/harvest*`) with HiGHS fallback for unsupported sizes or missing binaries.
- CVXPYGEN `cpg_prim.x` is column-major (`order="F"` reshape) and must be interpreted that way; using row-major reshape silently breaks row-equality constraints.
- `scripts/compile_cvxpy.py` is a Click command (supports `--config config/compile_cvxpy.toml`) that builds `harvestN` extensions for each `N in 1..log2_size` into `{output_dir}` and packs `{output_dir}/cpg.tar.xz`; default `output_dir` is discovered via `phantom.common.distribute.cpg.solver` module introspection (solver file directory).
- On Windows, CVXPYGEN can fail if `generate_code` gets an absolute `code_dir` path because it imports `f"{code_dir}.cpg_solver"` as a module name; in `scripts/compile_cvxpy.py`, use `wrapper=False` and run `cpg.compile_python_module(str(build_dir))` explicitly instead.
- `scripts/compile_cvxpy.py`: keep both path mutations: prepend CMake dir to `PATH` (generated builds call `cmake` by name) and temporarily prepend `build_root` to `sys.path` (so `cpg.generate_code` can import generated `harvestN.cpg_solver`); these can be implemented as `insert`/`pop` instead of full `sys.path` copies.
- `scripts/compile_cvxpy.py` import verification must use `importlib.machinery.EXTENSION_SUFFIXES` (not only `.pyd`) so CI on Debian can validate generated extension modules (`.so`).
- Wheel packaging now expects packed CVXPYGEN binaries at `phantom/common/distribute/cpg/cpg.tar.xz` (included via `[tool.poetry].include`); `scripts/build.py` clears `build/`, so storing this artifact under `build/` is not stable.
